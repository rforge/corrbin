{
    "contents" : "setwd(\"/home/aszabo/EOGeorge/MultiTrend\")\nsource(\"MultiCAfunctions.R\")\nlibrary(ggplot2)\nlibrary(reshape2)\n\nrerunOverall <- FALSE\nrerunIndiv <- TRUE\n\n# power simulation - overall test\nsource(\"SimMultiSlope.R\")\n                         \n\n# generate matrices based on random average probability and\n# target in ncp.vec\nsim.set <- function(ncp.vec, K, nc, nvec, R0=5000, R1=1000,\n                    ngrid=21, maxit=100) {\n  res <- sapply(ncp.vec, function(ncp){\n      testp <- ran.pmatrix.ncp(ncp=ncp, K=K, nc=nc, nvec=nvec, ngrid=ngrid,\n                               maxit=maxit)\n      testp0 <- gen.pmatrix.linear(baseline.p = rowMeans(testp), nc=nc)\n      pwr <- simulate.test(multiCA.test, nvec=nvec, pmat=testp, R = R1)$power\n      pwr0 <- simulate.test(multiCA.test, nvec=nvec, pmat=testp0, R = R0)$power\n      calcpwr <- multiCA.power(testp, nvec=nvec)\n      ncp.calc  <- multiCA.ncp(testp, nvec=nvec)\n      c(ncp, ncp.calc, pwr0, pwr, calcpwr)\n  })\n  resd <- as.data.frame(t(res))\n  names(resd) <- c(\"ncp\",\"ncp.calc\",  \"power0\", \"power1\", \"power.calc\")\n  resd <- transform(resd, se1 = sqrt(power1 * (1-power1)/R1),\n                    se0 = sqrt(power0 * (1-power0) / R0))\n  resd\n}\n\n# generate a new random matrix for every simulation\n# eliminate explicit H0 generation\n# all combinations of ncp and per-group sample size\nsim.set.v2 <- function(ncp.vec, ss.vec, K, nc, R=1000, ngrid=21, maxit=100) {\n  simone <-  function(ncp, n){\n      nvec <- rep(n, nc)\n      testp <- ran.pmatrix.ncp(ncp=ncp, K=K, nc=nc, nvec=nvec, ngrid=ngrid,\n                               maxit=maxit)\n      pwr <- simulate.test(multiCA.test, nvec=nvec, pmat=testp, R = 1)$power\n      calcpwr <- multiCA.power(testp, nvec=nvec)\n      c(ncp, n, calcpwr, pwr)\n  }\n  simmany <- function(ncp, n){\n      tmp <- replicate(R, tryCatch(simone(ncp, n), error=function(e)c(ncp,n,NA,NA)))\n      rowMeans(tmp, na.rm=TRUE)\n  }\n  res <- mapply(simmany, rep(ncp.vec, each=length(ss.vec)), rep(ss.vec, length(ncp.vec)))\n  resd <- as.data.frame(t(res))\n  names(resd) <- c(\"ncp\", \"n\", \"power.calc\", \"power\")\n  resd$K <- K\n  resd <- transform(resd, se = sqrt(power * (1-power)/R))\n  resd\n}\n\n\n\nif (rerunOverall){\n    set.seed(346236)\n    s3 <- sim.set.v2(ncp.vec=0:30, ss.vec=c(20, 50, 100), K=3, nc=5, ngrid=21, R=1000)\n    s5 <- sim.set.v2(ncp.vec=0:30, ss.vec=c(20, 50, 100), K=5, nc=5, ngrid=21, R=1000)\n    s7 <- sim.set.v2(ncp.vec=0:30, ss.vec=c(20, 50, 100), K=7, nc=5, ngrid=21, R=1000)\n\n    s3a <- sim.set.v2(ncp.vec=0, ss.vec=seq(10, 100, by=5), K=3, nc=5, ngrid=21, R=5000)\n    s5a <- sim.set.v2(ncp.vec=0, ss.vec=seq(10, 100, by=5), K=5, nc=5, ngrid=21, R=5000)\n    s7a <- sim.set.v2(ncp.vec=0, ss.vec=seq(10, 100, by=5), K=7, nc=5, ngrid=21, R=5000)\n\n    simres <- rbind(s3, s5, s7)\n    simres.a <- rbind(s3a, s5a, s7a)\n    save(simres, simres.a, file=\"SimOverallv2.RData\")\n} else {\n    load(file=\"SimOverallv2.RData\")\n}\n\ntheme_set(theme_bw(base_size = 12))\npdf(file=\"PowerSim.pdf\", width=10, height=8)\nggplot(filter(simres, is.finite(n)), aes(x=ncp, y=power)) + facet_grid(n~K, labeller = label_both) +\n  geom_pointrange(aes(ymin=power-1.96*se, ymax=power+1.96*se)) +\n  geom_line(aes(y=power.calc), colour=\"red\") +\n  scale_y_continuous(\"Power\", limits=c(0, 1)) +\n  scale_x_continuous(\"Non-centrality parameter\")   \ndev.off()\n\npdf(file=\"PowerSim2.pdf\", width=10, height=8)\nggplot(filter(simres, is.finite(n) & ncp < 30), aes(x=power.calc, y=power)) + facet_grid(n~K, labeller = label_both) +\n  geom_pointrange(aes(ymin=power-1.96*se, ymax=power+1.96*se)) +\n  geom_line(aes(y=power.calc), colour=\"red\") +\n  scale_y_continuous(\"Power\", limits=c(0, 1)) +\n  scale_x_continuous(\"Non-centrality parameter\") \ndev.off()\n\n\npdf(file=\"TypeISim.pdf\", width=8, height=4)\nggplot(simres.a, aes(x=n, y=power))  + facet_grid(~K, labeller = label_both)  + \n  geom_pointrange(aes(ymin=power-1.96*se, ymax=power+1.96*se)) +\n  geom_hline(yintercept=0.05, slope=0, colour=\"red\") +\n  scale_y_continuous(\"Type I error\", limits=c(0, 0.07),expand=c(0,0)) +\n  scale_x_continuous(\"Sample size per group\") \ndev.off()\n  \n# individual tests \nmultiCA.test.mod <- function(x){\n  if (is.null(rownames(x))){rownames(x) <- 1:nrow(x)}\n  res <- multiCA.test(x)\n  p <- res$CA.p.values\n  n <- length(p)\n  \n  # Holm* adjustment\n    i <- seq_along(p)\n    i[2] <- 3\n    o <- order(p)\n    ro <- order(o)\n    p.holm <- pmin(1, cummax((n - i + 1L) * p[o]))[ro]\n  \n  # closed set\n  mytest <- function(hypotheses, data) partial.multiCA.test(data, hypotheses)\n  p.closed <- p.adjust.closed(mytest, rownames(x), data=x)  \n  c(res, list(adj.p.shaffer=p.holm, adj.p.closed=unname(p.closed)))\n}\n\n\ncompare.indiv <- function(test.fun, nvec, pmat, R=500, sig.level=0.05,\n                          indiv1=\"adj.p.shaffer\", indiv2=\"adj.p.closed\",\n                          H0s=1){\n  # \n  H0sig <- nsig <- c(0,0)\n  diff21 <- numeric(R)\n  for (i in 1:R){\n    x <- gen.data(nvec=nvec, pmat=pmat)\n    xres <- test.fun(x)\n    n1 <- sum(xres[[indiv1]][-H0s] <= sig.level)\n    n2 <- sum(xres[[indiv2]][-H0s] <= sig.level)\n    nsig <- nsig + c(n1, n2)\n    diff21[i] <- n2 - n1\n    H0sig <- H0sig + c(any(xres[[indiv1]][H0s] <= sig.level), any(xres[[indiv2]][H0s] <= sig.level))\n  }\n  c(c(H0sig, nsig)/R, mean(diff21), sd(diff21)/sqrt(R))\n}\n\n\n\n# generate matrices with given ncp and L constant rows\nsim.better <- function(ncp.vec, K, L, nc, nvec, R=1000, ngrid=21, maxit=100, overall.ncp=TRUE) {\n    simone <- function(ncp){\n        testp <- ran.pmatrix0.ncp(ncp=ncp, K=K, nc=nc, nvec=nvec, L=L, ngrid=ngrid,\n                            maxit=maxit, overall.ncp=overall.ncp)\n        p.alt.sum <- sum(testp[(L+1):K, 1])\n        ncp0 <- ncp * p.alt.sum\n        r <- compare.indiv(multiCA.test.mod, nvec=nvec, pmat=testp, R=R, H0s=1:L)\n        c(ncp, ncp0, r)\n    }\n  res <- sapply(ncp.vec, function(ncp){tryCatch(simone(ncp), error=function(e)c(ncp, rep(NA,7)))})\n  resd <- as.data.frame( t(res))\n  names(resd) <- c(\"ncp\",\"ncp0\", \"H0sig1\", \"H0sig2\",\"nsig1\", \"nsig2\", \"diff21\", \"se21\")\n  resd$K <- K\n  resd$L <- L\n  resd\n}\n\n\n\n# generate matrices with given ncp and L constant rows\n# generate new random matrix for every data set\nsim.better.v2 <- function(ncp.vec, K, L, nc, nvec, R=1000, ngrid=21, maxit=100, overall.ncp=TRUE) {\n    simone <- function(ncp){\n        testp <- ran.pmatrix0.ncp(ncp=ncp, K=K, nc=nc, nvec=nvec, L=L, ngrid=ngrid,\n                            maxit=maxit, overall.ncp=overall.ncp)\n        p.alt.sum <- sum(testp[(L+1):K, 1])\n        ncp0 <- ncp * p.alt.sum\n        r <- compare.indiv(multiCA.test.mod, nvec=nvec, pmat=testp, R=1, H0s=1:L)\n        c(ncp, ncp0, r)\n    }\n    simmany <- function(ncp){\n        tmp <- replicate(R, tryCatch(simone(ncp), error=function(e)c(ncp, rep(NA,7))))\n        avetmp <- rowMeans(tmp, na.rm=TRUE)\n        avetmp[8] <- sd(tmp[7,])/sqrt(R)  # se21 = sd(diff21)/sqrt(n)\n        avetmp\n    }\n    res <- sapply(ncp.vec, function(ncp){simmany(ncp)})\n  resd <- as.data.frame( t(res))\n  names(resd) <- c(\"ncp\",\"ncp0\", \"H0sig1\", \"H0sig2\",\"nsig1\", \"nsig2\", \"diff21\", \"se21\")\n  resd$K <- K\n  resd$L <- L\n  resd\n}\n\nif (rerunIndiv){\n    set.seed(346236)\n    r3 <- sim.better.v2(ncp.vec=0:30, K=3, nc=5, nvec=rep(100, 5), ngrid=21,\n                     R=5000, L=1)\n    r5 <- lapply(1:3, function(L){\n        sim.better.v2(ncp.vec=0:30, K=5, nc=5, nvec=rep(100, 5), ngrid=21,\n                   R=5000, L=L)})\n    r7 <- lapply(1:5, function(L){\n        sim.better.v2(ncp.vec=0:30, K=7, nc=5, nvec=rep(100, 5), ngrid=21,\n                   R=5000, L=L)})\n    \n    rres <- do.call(rbind, c(list(r3), r5, r7))\n    save(rres, file=\"SimIndividualv2.RData\")\n} else {\n    load(file=\"SimIndividualv2.RData\")\n}\n\ntheme_set(theme_bw(base_size = 12))\npdf(file=\"IndivPowerSim.pdf\", width=8, height=4)\nggplot(rres, aes(x=ncp, y=diff21, colour=factor(K-L), fill=factor(K-L))) + \n    geom_hline(yintercept=0, slope=0, colour=\"gray\") +\n    geom_ribbon(aes(ymin=diff21-1.96*se21, ymax=diff21+1.96*se21), colour=NA, alpha=0.3)+\n    geom_line() +\n    facet_grid(~K, labeller = label_both) +\n    scale_x_continuous(\"Non-centrality parameter\") +\n    scale_y_continuous(\"#sig [closed] - #sig [Holm*]\") \ndev.off()\n\nrres2 <- melt(rres, id.var=c(\"K\",\"L\", \"ncp\",\"ncp0\"), measure.vars = c(\"H0sig1\", \"H0sig2\"))\nrres2 <- transform(rres2, Method=ifelse(variable==\"H0sig1\", \"Holm*\", \"Closed set\"))\n\n\npdf(file=\"IndivTypeISim.pdf\", width=8, height=4)\nggplot(rres2, aes(x=ncp, y=value, colour=factor(K-L), fill=factor(K-L))) + \n    geom_hline(yintercept=0.05, slope=0, colour=\"red\") +\n    geom_ribbon(aes(ymin=value-sqrt(value*(1-value)/5000), \n                    ymax=value+sqrt(value*(1-value)/5000)), alpha=0.3, colour=NA)+\n    geom_line() +\n    facet_grid(Method~K, labeller = label_both) +\n    scale_x_continuous(\"Non-centrality parameter\") +\n    scale_y_continuous(\"Familywise type I error\", limit=c(0,0.075)) \ndev.off()\n\nrres3 <- melt(rres, id.var=c(\"K\",\"L\", \"ncp\",\"ncp0\"), measure.vars = c(\"nsig1\", \"nsig2\"))\nrres3 <- transform(rres3, Method=ifelse(variable==\"nsig1\", \"Holm*\", \"Closed set\"),\n                          KL = K-L)\n\n\nggplot(rres3, aes(x=ncp, y=value, colour=Method)) + \n    geom_hline(yintercept=0, slope=0, colour=\"gray\") +\n    geom_hline(aes(yintercept=KL), slope=0, colour=\"gray\") +\n    geom_line() +\n    facet_grid(KL~K, labeller = label_both, scales=\"free_y\") +\n    scale_x_continuous(\"Non-centrality parameter\") +\n    scale_y_continuous(\"#sig\") \n",
    "created" : 1461860374807.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2255567842",
    "id" : "E75A0B28",
    "lastKnownWriteTime" : 1461694173,
    "path" : "Z:/EOGeorge/MultiTrend/TalkFiles.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}